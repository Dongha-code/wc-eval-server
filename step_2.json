{
  "step": "STEP 2",
  "title": "태깅 구조와 로깅 흐름 이해",
  "sections": [
    "태그의 구조와 실행 흐름",
    "트리거, 변수, 파라미터/쿠키 설정",
    "커스텀 트리거 및 자바스크립트 작성 유의사항",
    "미리보기 기능과 설정법",
    "태그 실행 선후관계 및 실패 대응",
    "태그 관련 주요 메소드",
    "클릭 이벤트 및 필터 처리"
  ],
  "context": "[STEP 2-1] 태그의 구조와 실행 흐름\n[STEP 2-2] 트리거, 변수, 파라미터/쿠키 설정\n[STEP 2-3] 커스텀 트리거 및 자바스크립트 작성 유의사항\n[STEP 2-4] 미리보기 기능과 설정법\n[STEP 2-5] 태그 실행 선후관계 및 실패 대응\n[STEP 2-6] 태그 관련 주요 메소드\n[STEP 2-7] 클릭 이벤트 및 필터 처리\n[STEP 2-1] 태그의 구조와 실행 흐름\n✅ 개념 요약\nWiseCollector에서 태그란 지정된 조건(트리거)이 충족되었을 때 실행되는\n로그 수집 단위\n를 의미합니다.\n태그는 UI(Manager)에서 등록되며,\n트리거 → 변수 → 태그 실행 → 로그 수집\n이라는 흐름을 따릅니다.\n각 태그는 클릭, 페이지뷰, 사용자 이벤트 등 다양한 행동을 기반으로 조건을 설정할 수 있으며,\n실행 시 파라미터와 쿠키 정보가 함께 기록\n되어 이후 변환 및 분석 작업에 활용됩니다.\n✅ 태그 실행 흐름 요약\n[사용자 이벤트] → [트리거 조건 충족] → [태그 실행] → [파라미터/쿠키 삽입] → [로그 전송]\n💡 예시 시나리오\n사용자가 버튼 클릭\n→ clickElement 트리거 조건 충족\n→ ntm.js에서 해당 태그 실행\n→ \"상품ID=123\" 정보가 파라미터에 포함되어 로그 전송\n→ Nlogger에서 수신 → ClickHouse 저장\n✅ 태그의 주요 구성 요소\n요소\n설명\n트리거(Trigger)\n태그 실행을 유도하는 사용자 행동 (예: 클릭, URL 변경)\n변수(Variable)\n로그에 포함될 추가 정보 (예: 상품 ID, 페이지명)\n파라미터/쿠키 설정\n변수 데이터를 파라미터 또는 쿠키 형태로 로그에 포함\n우선순위 및 예외처리\n복수 트리거 또는 예외 조건 설정 가능\n태그 실행 방식\n동기, 비동기 방식 모두 지원 (SPA 대응 포함)\n✅ 태그 적용 예시\nNtm.Variable.addOnParam({\n  \"product_id\": \"12345\",\n  \"category\": \"shoes\"\n});\n\nNtm.Variable.addOnCookie({\n  \"user_id\": \"A10001\"\n});\n위와 같은 방식으로 태그 실행 시 자동으로 파라미터와 쿠키에 정보가 추가됨\n태그 실행 이후, 로그에 아래와 같은 형태로 기록됨:\n...?product_id=12345&category=shoes (파라미터)\n쿠키: user_id=A10001\n📌 학습 체크포인트\n태그는 어떤 구조로 실행되며, 어떤 요소들이 연결되어 있는가요?\n트리거, 변수, 파라미터/쿠키는 각각 어떤 역할을 하나요?\n태그 실행 시 로그에 기록되는 정보는 어떤 방식으로 구성되나요?\n트리거 조건을 만족하지 않을 경우 태그는 어떻게 동작하나요?\n[STEP 2-2] 트리거, 변수, 파라미터/쿠키 설정\n✅ 개념 요약\nWiseCollector의 태그 실행은 트리거(Trigger)를 통해 시작되며, 변수(Variable)는 태그 실행 시 로깅할 정보를 담습니다.\n이 변수들은\n파라미터 또는 쿠키\n형태로 로그에 저장되어 분석 시 주요 기준값으로 활용됩니다.\n✅ 트리거 (Trigger)\n💡 역할\n사용자의 특정 행동(클릭, 페이지 진입 등)이 발생했을 때\n태그를 실행시키는 조건\n을 구성합니다.\n💡 주요 속성\n항목\n설명\n이벤트 유형\nclick, submit, pageview 등\n조건\nURL 일치, 클릭한 요소의 ID/class 등\n예외 트리거\n해당 조건일 경우\n태그 실행 방지\n예:\nfavourite_space\n메뉴 클릭 시 click_item이라는 변수로 로그 남김\n→ 트리거 실행 → 태그 실행 → 파라미터/쿠키 생성\n✅ 변수 (Variable)\n💡 역할\n태그 실행 시 함께 전송할\n데이터 항목\n들을 담고 있음\n기본 변수, 사용자 정의 변수(customData), 변수 그룹 등을 사용 가능\n💡 설정 방식 예시\nNtm.Variable.addOnParam({\n  \"product_id\": \"12345\"\n});\n\nNtm.Variable.addOnCookie({\n  \"user_id\": \"A10001\"\n});\n💡 동일한 변수를\n파라미터와 쿠키\n에 동시에 넣을 수도 있음\n✅ 파라미터 및 쿠키 설정\n항목\n설명\n파라미터\n로그 URL에\n?key=value\n형태로 추가됨 (예:\n?click_item=ABC\n)\n쿠키\n브라우저 쿠키 영역에 저장되어 사용자 단위 추적 시 활용\n사용처\n이동경로 분석, 시나리오 분석, 사용자 그룹 분류 등에서 활용됨\n💡 파라미터/쿠키는\n동일한 변수명을 다른 형태로 중복 설정 가능\n예: 파라미터\nuser_id=A10001\n, 쿠키\nuser_id=A10001\n📌 실무에서의 팁\n트리거는 가능한 한\n명확한 조건\n을 설정하여 불필요한 태그 실행을 방지합니다.\n변수는\n지속 가능한 정보 (상품 ID, 사용자 ID 등)\n중심으로 구성합니다.\n쿠키는\n보안 설정과 도메인 범위\n에 주의 필요합니다.\n📌 학습 체크포인트\n트리거는 어떤 조건일 때 태그를 실행시키나요? 예외 조건은 어떻게 처리하나요?\n변수는 어떤 역할을 하며, 파라미터와 쿠키에 어떻게 분기되나요?\n실제 로그에 파라미터가 포함되는 방식과 쿠키에 저장되는 방식의 차이점은 무엇인가요?\n사용자 정의 변수는 어떤 상황에서 사용하면 좋을까요?\n[STEP 2-3] 커스텀 트리거 및 자바스크립트 작성 유의사항\n✅ 개념 요약\n커스텀 트리거(Custom Trigger)는 ntm.js가 자동으로 감지하지 못하는 사용자 동작(앱 내 이벤트, AJAX 완료 등)에 대해\n직접 이벤트를 호출하여 태그를 실행시키는 방식\n입니다.\nNtm.Event.fireUserDefined()\n함수를 사용하여 특정 타이밍에 직접 트리거를 발생시키고, 이를 태그 관리기에서 조건으로 감지합니다.\n또한, 태그나 변수 설정 시 사용하는\n자바스크립트는 웹 성능과 디버깅 편의성을 고려해 작성\n해야 하며, 과도한 DOM 탐색, 반복 계산 등을 피하는 것이 중요합니다.\n✅ 커스텀 트리거 사용 시나리오\n상황\n설명\nSPA 페이지에서 URL 변경 없이 콘텐츠 변경\nfireUserDefined로 사용자 정의 트리거 발생\n앱 내 WebView에서 특정 이벤트 발생\n앱 → Web → JS 함수 호출로 연동\n백엔드 응답 완료 후 태그 실행\nAjax 콜백 내 fireUserDefined 호출\n💡 예시\nif (window.Ntm) {\n  Ntm.Event.fireUserDefined(\"custom_click\");\n}\n위 코드 실행 시\ncustom_click\n이라는 이름의 커스텀 트리거가 발생합니다.\n해당 이름은 태그 설정에서 “트리거 이름”으로 등록되어 있어야 합니다.\n✅ customData 변수와 연동\n커스텀 트리거에서 함께 전달되는 값은 기본 변수\ncustomData\n를 통해 로그에 남길 수 있습니다.\nNtm.Variable.addOnParam({\n  \"customData\": \"App_Intro_View\"\n});\n→ 로그에는\ncustomData=App_Intro_View\n형태로 기록됨\n✅ 자바스크립트 작성 시 유의사항\n과도한 DOM 트리 탐색 지양\ndocument.querySelector()\n를 반복 호출하면 성능 저하\n미리 변수에 담아 재사용하거나, 최상위 DOM만 접근\n과도한 정규표현식(match 등) 사용 주의\n문자열 비교 대비 2~5배 연산 비용 발생\n변수 재사용 및 캐싱\n동일 URL 기준 계산된 값은\nsessionStorage\n나\n쿠키\n에 저장하여 활용\nSPA 대응 시 NTMREADY 체크\nntm.js가 로드되기 전에 fireUserDefined 호출 시 이벤트가 누락될 수 있으므로, 반드시 Ntm 객체 존재 여부 확인 후 실행\n📌 학습 체크포인트\nfireUserDefined 함수는 어떤 상황에서 사용되며, 실행 조건은 무엇인가요?\n커스텀 트리거와 customData 변수의 연계 방식은 어떻게 구성되나요?\n자바스크립트 내에서 DOM 탐색과 변수 재사용을 구분해 설명할 수 있나요?\nSPA 환경에서 커스텀 트리거가 누락되지 않게 하려면 어떤 순서를 지켜야 하나요?\n[STEP 2-4] 미리보기 기능과 설정법\n✅ 개념 요약\n미리보기 기능\n은 태깅 설정을 실제 서비스에 반영하기 전에, 설정한 태그나 트리거가 정상적으로 동작하는지 확인할 수 있도록 지원합니다.\n미리보기는 웹사이트 내에서 테스트 가능하며, 로깅이 실제로 발생하는지 확인하고, 필요시\n스크립트를 콘솔에서 직접 실행하여 디버깅\n할 수 있습니다.\n✅ 미리보기 기능의 활용 방식\n1. 기본 미리보기 흐름\n단계\n설명\n① 태깅 관리기 상단에서\n미리보기 버튼 클릭\n테스트용 웹 페이지가 새로 열림\n②\n웹페이지 하단에 미리보기 모드\n표시\n별도 UI 바 생성\n③\n[테스트] 메뉴 진입 후\n페이지 내 클릭 또는 이동 테스트 수행\n이벤트 발생 시 로깅 결과 확인\n④ 미리보기 종료 후 → 적용 여부 선택\n설정 반영 여부 결정 가능\n→ 미리보기 모드에서 [적용] 버튼을 눌러도 실제 서비스에는 반영되지 않으며,\n단순 실행 테스트\n용도임\n2. 스크립트 복사 및 수동 테스트\nAlt + 적용 버튼\n클릭 시, 현재 설정된 스크립트가 클립보드에 복사됨\n브라우저의\n개발자 콘솔(F12 → Console 탭)\n에 붙여넣어 실행 가능\n페이지 이동 시 다시 붙여넣어야 하며, 콘솔 로그 또는 로컬스토리지를 통해 이벤트 확인 가능\n로그 확인 예시:\nNtm.Plugin.nlogger.download(\"tag_test_log\")\n→ CSV로 로그 다운로드 가능\n✅ 환경 설정 요구사항 (HTTPS 사이트 대응)\nManager 서버가 HTTPS를 지원해야 함\n설정 예시:\nlogging.script.ntm.preview.host=https://manager_ip:port\nHTTPS 인증서가 적용되지 않은 경우\n프록시 서버를 경유하여 스크립트 전달\n가능\n설정파일:\napplication.properties\nserver.ssl.enable=true\nserver.ssl.key-store=경로/nlog.pfx\n→ 사이트 보안 정책에 따라 방식 선택 필요\n📌 학습 체크포인트\n미리보기 모드에서 실제 서비스에 반영되는가요?\nAlt + 적용 버튼을 누르면 어떤 작업이 실행되나요?\nHTTPS 사이트에서 미리보기를 사용하려면 어떤 조건이 필요하나요?\n콘솔에서 실행한 미리보기 스크립트로 어떤 결과를 확인할 수 있나요?\n[STEP 2-5] 태그 실행 선후관계 및 실패 대응\n✅ 개념 요약\nWiseCollector 태그 실행 시,\n변수 처리 순서와 실행 타이밍\n이 중요한 요소로 작용합니다.\n특히 변수는 파라미터 또는 쿠키로 기록되며,\n설정 순서와 실행 시점에 따라 로그 기록에 영향을 미칩니다.\n또한 로직/타이밍/브라우저 속도 등의 이유로\n일부 태그 실행이 실패하거나 파라미터가 누락\n되는 경우도 있어, 이에 대한 대응 방안이 마련되어야 합니다.\n✅ 태그 실행 순서 규칙\n변수 처리 순서\n태그 실행 시 변수는\n파라미터 → 쿠키 순서\n로 처리됩니다.\n동일한 키가 존재할 경우,\n마지막 선언된 값이 적용\n됩니다.\n변수 처리 우선순위\naddOnParam()\n,\naddOnCookie()\n→ 일시적 덮어쓰기\nclearAddOnData()\n→ 이전 일시 변수 제거\nNtm.Variable.addOnParam({ \"user_id\": \"abc\" });\nNtm.Variable.clearAddOnData();\n예: 변수 중복 시\ntest2\n값이 마지막에 들어가면,\ntest1\n은 무시됩니다\n✅ 실패 대응 시나리오 및 대처법\n이슈 유형\n원인\n대응 방법\n변수 누락 (CASE 1)\nDOM 로드 이전에 태깅 실행\n트리거를\nwindow.onload\n로 변경하여 로딩 완료 후 실행\n변수 누락 (CASE 2)\n비동기 데이터 수신 전 태그 실행\nsetTimeout()\n지연 호출 또는 변수 대기 로직 삽입\n값 존재 확인 실패\n전역 변수 또는 쿠키 미정의\nif(window.xxx)\n조건 확인 후 호출\n중복 로그 발생\n동일 태그가 여러 번 실행\n조건문 추가 또는\nFLAG\n변수 활용\n커스텀 이벤트 중복 실행\nfireUserDefined()\n를 다중 호출한 경우\n호출 위치 조정 또는 1회 호출 보장 처리\n✅ 타이밍 이슈 실전 예시\nsetTimeout(function() {\n  Ntm.Variable.addOnParam({ \"user_id\": \"A123\" });\n  Ntm.Event.fireUserDefined(\"custom_view\");\n}, 200);\n비동기 로딩 환경에서는 위와 같은\n딜레이 호출\n이 필요할 수 있음\n단,\nsetTimeout은 최후의 수단\n이며, 구조적으로 해결하는 것이 우선\n📌 학습 체크포인트\n태그 실행 시 변수는 어떤 순서로 적용되며, 우선순위 충돌 시 어떻게 처리되나요?\n트리거가 실행되었지만 로그가 누락될 수 있는 원인은 무엇인가요?\nsetTimeout()\n으로 해결한 예제는 어떤 위험성을 가질 수 있나요?\n파라미터 누락 시 단순히 태깅 로직만 확인해서는 안 되는 이유는 무엇인가요?\n[STEP 2-6] 태그 관련 주요 메소드\n(fireUserDefined, NTMREADY, setTimeout, 페이지 이동 대응 등)\n✅ 개념 요약\nWiseCollector에서는\nntm.js가 로드되지 않았거나, 태그 실행 조건이 복잡한 상황\n에서 트리거를 수동으로 발생시키기 위한 내장 메소드들을 제공합니다.\n이 중\nNtm.Event.fireUserDefined()\n는 커스텀 트리거 실행의 핵심이며, 비동기 실행과 초기화 타이밍 문제를 해결하기 위해 **\nNTMREADY 이벤트\n**와\nsetTimeout()\n함수와 함께 사용됩니다.\n✅\nNtm.Event.fireUserDefined()\n메소드\n기능\n커스텀 트리거를 강제로 실행\n사용 시점\nSPA 환경, 웹뷰, 동적 페이지 전환 등\n전달 값\n트리거명, 로그에 남길 customData 등\n주의점\nntm.js 로딩 전 실행 시 동작 실패 가능성 있음\n💡 예시\nNtm.Event.fireUserDefined(\"custom_click\", \"menu_A\");\n태그 관리기에서\n\"custom_click\"\n이라는 트리거가 등록되어 있어야 정상 실행됨\n두 번째 파라미터\n\"menu_A\"\n는 customData로 로그에 남을 수 있음\n✅\nNTMREADY\n이벤트\nntm.js가 로딩되기 전에 fireUserDefined가 호출되면\n트리거 실행이 실패\n할 수 있습니다.\n이를 해결하기 위해\nNTMREADY\n이벤트를 통해\nntm.js 로딩 이후에 트리거를 호출하도록 지연 등록\n합니다.\n💡 예시\nif (window.Ntm) {\n  Ntm.Event.fireUserDefined(\"ntmReady_test\", \"test1\");\n} else {\n  window.addEventListener(\"NTMREADY\", function () {\n    Ntm.Event.fireUserDefined(\"ntmReady_test\", \"test2\");\n  });\n}\n💡\nNTMREADY\n이벤트는 ntm.js가 로딩되면 자동으로 브라우저에서 발생함\n✅\nsetTimeout()\n함수로 비동기 실행 제어\nntm.js 로딩보다 먼저 fireUserDefined가 실행되지 않도록\n딜레이를 걸어\n조절합니다.\n💡 예시\nsetTimeout(function() {\n  Ntm.Event.fireUserDefined(\"custom_event\");\n}, 200);\n최소 100~500ms 정도 지연\n을 주어 페이지 초기화와 ntm.js 로딩을 보장\n특히\n페이지 이동 직후\n커스텀 트리거를 실행하는 경우 매우 중요\nSPA에서는 페이지 이동 → setTimeout → 커스텀 트리거 실행의 순서 보장이 핵심입니다\n✅ 페이지 이동 시 커스텀 트리거 적용 가이드\n상황\n설명\n페이지 이동 즉시 fireUserDefined 실행\nntm.js가 아직 로드되지 않아 실패 가능\n해결 방법\nfireUserDefined 포함 함수 자체를 setTimeout 내부에서 호출\n💡 예시\nfunction triggerCustomEvent() {\n  Ntm.Event.fireUserDefined(\"page_view_complete\");\n}\n\nsetTimeout(triggerCustomEvent, 300);\n중첩 트리거 방지:\n바로 호출하면 재귀 발생 가능성 있음\n, 반드시\n딜레이 사용 권장\n📌 학습 체크포인트\nfireUserDefined는 어떤 상황에서 사용되며, 실패 시 어떤 방식으로 보완할 수 있나요?\nNTMREADY 이벤트의 역할은 무엇이며, 어떤 시점에 발생하나요?\nsetTimeout() 함수는 왜 필요한가요? 그 사용이 문제가 될 수 있는 경우는?\nSPA 페이지에서 커스텀 트리거를 안전하게 실행하려면 어떤 패턴이 필요한가요?\n[STEP 2-7] 클릭 이벤트 및 필터 처리\n✅ 개념 요약\nWiseCollector에서 클릭 이벤트는 사용자 행동을 기반으로 태그를 실행하는 핵심 조건 중 하나입니다.\n하지만 실제로는 사용자가 클릭한 것이 아닌,\n스크립트나 자동화된 테스트 도구 등이 발생시킨 가짜 클릭 이벤트\n가 수집되는 경우도 있어 이를 필터링하기 위한 안전장치가 필요합니다.\n또한\n클릭 트리거가 정상 동작하지 않는 예외 케이스\n에 대한 테스트 방법도 중요합니다.\n✅ 클릭 이벤트 필터 처리\n💡 이슈 배경\n사용자가 아닌 스크립트, 타사 SDK, 또는\ndispatchEvent()\n등을 통해 인위적으로 발생시킨 이벤트가 태그 실행을 유발\n이로 인해\n불필요한 로그 누적\n,\n오류 분석 방해\n,\n정확도 저하\n등 부작용 발생\n💡 필터링 방식\n방법\n설명\nEvent.isTrusted\n사용자가 발생시킨 이벤트 여부를 판별하는 Web API.\ntrue\n일 경우 사용자 동작,\nfalse\n일 경우 스크립트 발생\nEvent.pointerId\n실제 마우스/터치 입력의 식별자. 일부 상황에서 활용 가능\nif (event.isTrusted) {\n  // 진짜 클릭일 경우에만 태그 실행\n}\n참고:\nMDN - Event.isTrusted\n✅ 클릭 트리거 작동하지 않는 경우 테스트 가이드\n💡 테스트 목적\n트리거 바인딩 여부\n확인 (클릭 자체가 감지되지 않는 경우 확인용)\n💡 테스트 코드\ndocument.querySelector('button').addEventListener('click', function() {\n  console.log('CLICK');\n});\n위 코드를 콘솔에서 실행 후 클릭\n\"CLICK\" 메시지가 출력되지 않으면\n→ 요소에 이벤트 바인딩이 되지 않은 것\n💡 태그 문제보다\nHTML 요소 또는 JS 구조 문제일 가능성\n있음\n✅ 처리 대기시간 설정\n특정요소 클릭 트리거는\n복수 트리거 또는 예외조건\n이 있는 경우,\n최대 대기시간(기본 100ms)\n동안 발생한 클릭을 판단함\n해당 시간 설정이 없으면\n중복 트리거 또는 예외 트리거 무시 문제\n발생 가능\n💡 SPA에서는 클릭 후 페이지 이동이 빠르게 발생하면 URL 값이 이동된 후로 기록될 수 있음 → 대기시간 설정 필수\n📌 학습 체크포인트\nEvent.isTrusted 속성은 어떤 상황에서 유용하게 활용되나요?\n클릭 이벤트가 바인딩되지 않은 요소는 어떻게 테스트할 수 있나요?\n클릭 트리거 대기시간 설정이 필요한 이유는 무엇인가요?\nSPA 환경에서 클릭 트리거가 잘못 작동할 수 있는 원인을 설명할 수 있나요?\n[STEP 2-8] 컨테이너 고급 설정 및 디버깅 도구 활용법\n✅ 개념 요약\nWiseCollector는 다양한 운영 환경을 고려하여\n컨테이너 단위로 세부 설정을 오버라이드\n할 수 있도록 ‘고급 설정’ 기능을 제공합니다.\n또한 개발자 콘솔을 활용한 로깅 확인, 안드로이드 웹뷰 환경의 디버깅 가이드, 주요 내장 메소드 사용법 등도 함께 알아야 할 필수 항목입니다.\n✅ 컨테이너 고급 설정 가이드\n💡 설정 목적\n전체 환경에 영향을 주지 않고\n개별 컨테이너별 설정 분리\n가능\n패치 시 설정이 원복되거나 모든 사이트에 영향이 가지 않도록 보완 목적\n💡 설정 메뉴 위치\n/container/settings/{컨테이너 ID}\n💡 주요 기능 항목\n항목\n설명\n요청 주소 강제 설정\n수집 서버 요청 주소 지정\nURL 히스토리 상태 변경 시 트리거 발동 여부\npushState/replaceState 발생 시 트리거 실행 여부 설정\nXHR 요청 여부\n비동기 요청 시 JavaScript 실행 방식 설정 (기본값: XHR)\n전송방식\nGET / POST 선택 가능 (기본값: GET)\n✅ 브라우저 콘솔에서 로깅 실행 확인\nNtm.Plugin.nlogger.download(\"log_test\")\n콘솔에서 실행 시, 수집된 로그를 CSV 형태로 다운로드\n실시간 미리보기 확인 불가할 경우 수동 로그 확인용으로 활용 가능\n✅ Ntm 내장 메소드 예시\n메소드\n설명\nNtm.Variable.get(\"clickElement\")\n클릭한 요소 정보 가져오기\nNtm.Cookie.set()\n/\nget()\n쿠키 생성 및 조회\nNtm.Event.fireUserDefined()\n커스텀 트리거 실행\nNtm.Plugin.nlogger.download()\n로그 수동 다운로드 실행\n💡\nclickElement\n는 undefined 오류 발생 가능성이 있으므로 반드시 예외처리 필요\n✅ PCID 관련 설정\n최초 방문자 식별용 고유값으로, 설정에 따라 발급 여부 결정됨\n설정 위치:\nmanager/assets/plugins/nlogger.json\n설정 예시:\n\"always\": true\n→ 항상 PCID 발급\n✅ 디버깅 시 404 에러 대응 (안드로이드 웹뷰)\n💡 문제 상황\nMac/Windows PC에 설치된 Chrome 버전과 디버깅을 위한 안드로이드 기기의 Chrome 버전이 다를 경우 크롬 인스펙터(inspect)가 작동하지 않음\n💡 해결 방법\nchrome://inspect\n페이지 접속\n콘솔에서 아래 명령어 실행\nsendCommand = function(_, args) {\n  chrome.send('inspect-fallback', Array.prototype.slice.call(arguments, 1))\n};\ninspect fallback 버튼이 노출되면 해당 버튼으로 디버깅 전환 가능\n📌 학습 체크포인트\n컨테이너 고급 설정 메뉴는 어떤 목적에 사용되며, 어디서 접근 가능한가요?\nNtm 내장 함수 중\nget\n,\nset\n,\nfireUserDefined\n는 각각 어떤 기능을 하나요?\nPCID 발급 여부는 어떤 설정 파일에서 조정 가능한가요?\n웹뷰에서 inspect fallback 버튼을 띄우는 방법을 설명할 수 있나요?"
}