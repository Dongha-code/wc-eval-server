{
  "step": "STEP 4",
  "title": "로그 수집 설정",
  "sections": [
    "로그 위치 및 레벨 설정",
    "로그 유지 기간 및 STDOUT 설정",
    "수집서버 CORS, Headers 설정",
    "Access Log 남기기, 에러 방지 옵션",
    "millisecond/unixtime 기록 방식",
    "요청 URL 길이 제한 및 x-forwarded-for"
  ],
  "context": "[STEP 4-1] 로그 위치 및 레벨 설정\n[STEP 4-2] 로그 유지 기간 및 STDOUT 설정\n[STEP 4-3] 수집서버 CORS, Headers 설정\n[STEP 4-4] Access Log 남기기, 에러 방지 옵션\n[STEP 4-5] millisecond/unixtime 기록 방식\n[STEP 4-6] 요청 URL 길이 제한 및 x-forwarded-for\n[STEP 4-1] 로그 위치 및 레벨 설정\n✅ 개념 요약\nWiseCollector 구성요소(Manager, Agent, Nlogger 등)는 각각 별도의 로그 파일을 저장하며, 운영 중 발생하는 각종 이벤트와 에러, 디버깅 정보를 기록합니다.\n이 로그는\n문제 진단, 운영 안정성 확보, 이상 행위 분석\n등에 활용됩니다.\n✅ 로그 위치 설정\n각 실행 스크립트 혹은 설정 파일 내에 로그 저장 경로를 지정할 수 있습니다.\n💡 예시 경로\nManager 로그:\n/WiseCollector/manager/logs/\nAgent 로그:\n/WiseCollector/agent/logs/\n💡 커스텀 설정 예시 (startup.sh 또는 run.sh 내)\nexport CONSOLE_LOG_DIR=\"/var/log/wc/\"\n또는 config.json 내:\n\"consoleDir\": \"/custom/log/path\"\n💡 경로 변경 시 디스크 용량, 로그 순환 주기, 백업 정책 등을 함께 고려해야 합니다.\n✅ 로그 레벨 설정\n로그 레벨은\n기록의 상세 정도\n를 제어합니다. 레벨이 낮을수록 더 많은 정보가 기록됩니다.\n로그 레벨\n설명\nERROR\n심각한 오류만 기록 (기본 운영 시 권장)\nWARN\n경고 및 주의 사항 포함\nINFO\n일반적인 정보 기록 (기본 설정)\nDEBUG\n상세한 디버깅 정보 (개발·분석 시 사용)\n💡 설정 예시 (logback.xml 또는 log4j2.xml)\n<root level=\"INFO\">\n  <appender-ref ref=\"console\"/>\n</root>\n⚠️ DEBUG 모드는 운영 환경에서 사용 시 로그 과다로 시스템 자원 소모 우려 있음\n📌 학습 체크포인트\n시스템 로그가 저장되는 기본 위치는 어디이며, 어떻게 변경할 수 있나요?\n로그 레벨은 어떤 값이 있고, 각각 어떤 상황에서 적합하게 사용되나요?\nDEBUG 모드를 운영 환경에서 장기 사용했을 때의 위험 요소는 무엇인가요?\n[STEP 4-2] 로그 유지 기간 및 STDOUT 설정\n✅ 개념 요약\nWiseCollector에서는 시스템 로그의\n보존 기간\n과\n출력 방식\n을 설정할 수 있으며, 특히 STDOUT 출력 여부는\nDocker 환경 또는 클라우드 기반 운영 시 중요\n한 항목입니다.\n운영 로그가 무한정 쌓이는 것을 방지하거나, 외부 수집 시스템과 연계 시 유용하게 활용됩니다.\n✅ 로그 유지 기간 설정\n💡 설정 항목 예시 (logback 또는 관리 시스템 설정 파일)\nlog.access.retentionDays=30\n값\n의미\n30\n30일간 로그 보관\n0\n무기한 보관\n7\n일주일 후 자동 삭제\n💡 이 설정은\n접속 로그, 관리자 활동 로그\n등에 주로 적용됩니다.\n로그는 오래 보관할수록 보안 감사에 유리하지만,\n디스크 용량 관리와 트레이드오프 관계\n입니다.\n✅ STDOUT 로그 출력 설정\nSTDOUT 출력을 활성화하면, 로그가\n파일이 아닌 표준 출력(console)\n으로 출력됩니다.\n일반적으로 컨테이너 환경(Docker/Kubernetes)에서 사용됩니다.\n로그 수집 시스템(예: Datadog, Fluentd 등)과 연계하기 위해 필수일 수 있음\n💡 예시 설정 (logback.xml 또는 spring boot 설정 기준)\nlogging.pattern.console=%d{HH:mm:ss.SSS} %-5level %logger{36} - %msg%n\n💡 STDOUT 출력은 디버깅에는 유용하지만,\n파일 백업이나 오프라인 분석 시 불리\n할 수 있습니다.\n운영 환경에서는\nSTDOUT + 파일 동시 출력 이중 설정\n도 고려됩니다.\n📌 학습 체크포인트\n로그 보관 주기를 설정하는 항목은 어떤 것이며, 기본값은 무엇인가요?\n로그를 무기한 보관하는 설정값은 어떤 영향을 미칠 수 있나요?\nSTDOUT 로그는 어떤 환경에서 주로 활용되며, 장단점은 무엇인가요?\n[STEP 4-3] 수집서버 CORS 및 Headers 설정\n✅ 개념 요약\nWiseCollector의 수집서버(Nlogger) 또는 프록시(Nginx)는 브라우저의 Cross-Origin 요청(CORS)을 처리해야 합니다.\n특히\n비동기 요청(XHR) 방식\n으로 로깅을 수집하는 경우,\nOPTIONS\n메서드를 이용한 Preflight 요청이 발생하며, 이 요청을 서버에서 적절히 허용하지 않으면 405 오류(Method Not Allowed)가 발생합니다.\n✅ 기본 CORS 설정 방법\n1. 수집서버 설정 (application.properties)\ncors.allowed-origin-pattern=*\nsecurity.web.allowed-methods= GET, POST, OPTIONS\nallowed-origin-pattern=*\n: 모든 도메인 허용 (보안상 문제 없을 경우만)\nallowed-methods\n: 기본적으로 GET, POST만 허용되며, OPTIONS 추가 필요\n⚠️\nOPTIONS 메서드가 누락되면 대부분의 최신 브라우저에서 로깅 실패\n✅ Nginx에서 OPTIONS 대응 설정\nNginx에서는\nOPTIONS\n요청을 정상적으로 처리하지 않으면 405 오류가 발생합니다.\n아래와 같이 처리하면 사전 요청에 올바르게 응답할 수 있습니다.\nif ($request_method = 'OPTIONS') {\n    add_header 'Access-Control-Allow-Origin' '*';\n    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, HEAD';\n    return 200;\n}\n💡\nAccess-Control-Allow-Methods\n에는 실제 사용하는 모든 메서드를 명시해야 합니다.\n✅ 브라우저 헤더 관련 주요 포인트\nHeader\n설명\nAccess-Control-Allow-Origin\n요청 Origin 허용 여부\nAccess-Control-Allow-Methods\n허용된 HTTP 메서드 명시\nAccess-Control-Allow-Headers\n(필요 시) 커스텀 헤더 허용 지정\nVary: Origin\n캐시 정책에 따라 응답 분리\n📌 학습 체크포인트\n수집서버에서 OPTIONS 요청을 허용하지 않으면 어떤 현상이 발생하나요?\nAccess-Control-Allow-Origin\n을\n*\n대신 지정된 도메인으로 제한하는 이유는 무엇인가요?\nNginx에서 OPTIONS 요청을 처리하기 위한 설정 블록은 어떻게 구성하나요?\n[STEP 4-4] Access Log 남기기 및 에러 방지 옵션\n✅ 개념 요약\nAccess 로그는 수집 서버 또는 프록시 서버(Nginx 등)에서 발생하는 모든 요청 내역을 기록\n합니다.\n로그 기록 형식과 저장 위치, 시점별 분리 설정 등을 통해\n분석 용이성\n과\n서버 부하 분산\n에 기여할 수 있으며, 에러 로그는 심각도에 따라 기록 수준을 조절해\n운영 안정성을 확보\n합니다.\n✅ Access 로그 남기기 설정 (Nginx 기준)\n문서 참고:\nhttps://nethru.atlassian.net/wiki/spaces/WC/pages/596344986\n💡 기본 구조\naccess_log  logs/access.log;\n💡 일자별 또는 시간별 파일 분리 예시:\nif ($time_iso8601 ~ \"^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2})\") {\n  set $year $1;\n  set $month $2;\n  set $day $3;\n  set $hour $4;\n}\naccess_log  logs/access_${year}${month}${day}${hour}.log;\n결과 파일 예시:\naccess_20250410_14.log\n실시간 로그 분석, 문제 발생 시점 추적에 유리함\n✅ Access 로그 비활성화 예시\n설정을 끄면 로그 자체가 기록되지 않음\naccess_log off;\n로그를 꺼야 할 필요는 거의 없으며, 성능 테스트 시에만 임시 적용 권장\n✅ 로그 포맷 설정 예시\nlog_format main '$remote_addr - $request $status $http_user_agent $http_x_forwarded_for';\n커스텀 포맷을 정의하고\naccess_log ... main;\n과 같이 사용\n✅ 에러 로그 레벨 조절\n💡 기본 설정\nerror_log  logs/error.log warn;\n로그 레벨\n설명\ndebug\n디버깅 용도, 과다 출력 위험\ninfo\n일반 정보\nwarn\n경고, 처리 지연 가능성\nerror\n기본 수준, 실제 오류 발생\ncrit\n서비스 영향 줄 수 있는 심각 오류\nemerg\n즉시 조치 필요, 서비스 중단 위험 수준\n💡 로그 비활성화 설정 (선택사항)\nerror_log /dev/null crit;\n/dev/null\n로 전송하면 해당 레벨 이하의 로그는 완전히 기록되지 않음\n📌 학습 체크포인트\naccess 로그를 시간별로 분리하면 어떤 장점이 있나요?\naccess_log off\n는 어떤 상황에서 사용하며, 운영 중 사용해도 될까요?\nerror 로그 레벨 중\nwarn\n,\ncrit\n,\nemerg\n는 각각 어떤 상황에서 활용되나요?\n로그를 /dev/null로 보내는 설정은 어떤 목적일 때 고려할 수 있나요?\n[STEP 4-5] millisecond / unixtime 기록 방식\n✅ 개념 요약\nWiseCollector는 로그에 타임스탬프 정보를 다양한 포맷으로 남길 수 있도록 지원합니다.\n기본적으로는 초 단위의\nunixTime\n을 기록하지만,\n밀리초 단위의 정밀한 시간 기록\n을 위해\nmillisOfSecond\n,\nunixTimeMillis\n등의 옵션도 함께 사용됩니다.\n이는 이벤트 정렬, 순차 비교, 지연시간 분석 등에 매우 유용합니다.\n✅ 로그 타임스탬프 설정\n💡 설정 위치:\nprocess.properties\nout.log.cookie.append=millisOfSecond,unixTime,unixTimeMillis\nmillisOfSecond\n: 초 내부의 밀리초(0~999)\nunixTime\n: UNIX timestamp (초 단위)\nunixTimeMillis\n: UNIX timestamp (밀리초 단위)\n설정 후\n수집 태스크 재시작\n시 적용됩니다.\n💡 적용 예시:\nuid=logger; millisOfSecond=023;\nunixTime=1609513200;\nunixTimeMillis=1609513200023;\n✅ 용도별 활용 예시\n필드\n설명\n예시\nunixTime\n이벤트 발생 시점의 초 기준 타임스탬프\n1609513200\nmillisOfSecond\n초 단위 내 0~999ms 정밀도 기록\n023\nunixTimeMillis\n밀리초 단위의 절대시간\n1609513200023\n실시간 처리 로직에서는\nunixTimeMillis\n로 정렬 → 순차성 보장\nmillisOfSecond\n는 로그 시간 겹침 여부 판단에 유리\n✅ 로그 타임 포맷 가공 방식 (선택사항)\n운영 중 로그를 수집하여 ClickHouse 또는 ElasticSearch와 같은 시스템으로 보낼 경우, millisecond 단위 타임스탬프를\n가공 포맷으로 변환\n하여 저장하거나 분석 지표로 활용할 수 있습니다.\ntoDateTime(unixTimeMillis / 1000)\nfromUnixTimestamp64Milli()\n사용 시 밀리초 단위 유지 가능\n주간별, 시간대별 필터링 용이\n📌 학습 체크포인트\nmillisOfSecond\n,\nunixTime\n,\nunixTimeMillis\n는 각각 어떤 시간 단위를 나타내나요?\n밀리초 단위의 로그 기록은 어떤 상황에서 특히 유용하게 사용될 수 있나요?\n로그 기록에 밀리초 단위 타임스탬프를 추가하려면 어떤 설정이 필요한가요?\nmillisecond\n정보를 활용해 로그 순서를 판단할 수 있는 이유는 무엇인가요?\n[STEP 4-6] 요청 URL 길이 제한 및 x-forwarded-for 설정\n✅ 개념 요약\nWiseCollector 수집 서버는\n브라우저 또는 프록시 서버를 통해 전달되는 로그 요청의 URI 길이에 제한\n을 두고 있으며, 이를 초과하면 수집이 실패합니다.\n또한\nx-forwarded-for\n헤더는\n프록시나 로드밸런서 뒤에 위치한 수집서버가 실제 클라이언트의 IP를 알 수 있도록\n도와주는 표준 방식입니다.\n이 두 설정은 모두\n정확한 로그 수집과 분석\n을 위해 필수적인 요소입니다.\n✅ 요청 URL 길이 제한\n💡 배경\n대부분의 브라우저와 서버는 URI 길이에 제한이 있으며, 이를 초과하면\nHTTP 413 오류\n가 발생합니다.\n예: 크롬에서 8K 이상, 수집서버 기본 설정은 4K 제한인 경우 존재\n📄 설정 예시 (수집서버)\n# 파일 위치: /nlog-server/bin/process.properties\nserver.netty.max-initial-line-length=8KB\nNetty 기반 수집서버는 이 옵션을 통해 URI의 최대 길이를 제어함\n보안 정책이나 분석 목적에 따라\n8KB 이상으로 확장\n가능\n💡 변환기(Converter)는 기본적으로 8KB 이상의 로그라인은 처리하지 않고 스킵함\n✅ 테스트 사례 요약 (문서 기반)\n브라우저\n4K 이하\n8K 이하\n8K 이상\n크롬\n✅ 정상\n✅ 정상\n❌ 413 오류\n엣지\n✅ 정상\n✅ 정상\n❌ 413 오류\n→ 운영 환경에서 수집 경로가 프록시를 경유할 경우, 프록시+서버 설정 모두 고려 필요\n✅ x-forwarded-for 설정\n💡 개념 설명\nX-Forwarded-For\n는\n클라이언트 → 프록시 → 수집서버\n구조에서 실제 요청자의 IP를 전달하기 위해 사용하는 HTTP 표준 헤더입니다.\nX-Forwarded-For: client1, proxy1, proxy2\n가장 앞에 오는 값(client1)이\n실제 사용자의 IP\n뒤따르는 값은\n중간 서버들\n의 IP\n💡 수집서버 동작 방식\nX-Forwarded-For\n값이 존재하면\n해당 값을 우선 사용\n하여 IP 기록\n없을 경우, 직접 전달된 요청의 IP(\nremote_addr\n) 사용\n💡 프록시 서버 설정 예시 (Nginx)\nproxy_set_header X-Real-IP $remote_addr;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n이 설정이 없다면 수집서버는\n프록시 IP만 인식\n하게 되어 사용자 식별이 어렵습니다\n📌 학습 체크포인트\n수집서버에서 URI 길이 제한이 초과되면 어떤 오류가 발생하나요?\nserver.netty.max-initial-line-length\n설정의 기본값과 목적은 무엇인가요?\nx-forwarded-for 헤더의 첫 번째 값과 두 번째 값은 각각 어떤 IP를 의미하나요?\n프록시 서버(Nginx)에서 사용자 IP를 수집서버에 정확히 전달하려면 어떤 설정이 필요한가요?"
}