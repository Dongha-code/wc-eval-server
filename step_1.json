{
  "step": "STEP 1",
  "title": "시스템 구성과 스크립트 이해",
  "sections": [
    "WC 2.0 운영 개요",
    "시스템 구성 요소 및 연동 흐름",
    "install.js와 ntm.js 차이 및 요청 프로세스",
    "스크립트 반영 주기 및 캐시",
    "스크립트 배포 방식 및 복사 기능",
    "스크립트 중복 삽입 방지 및 배포 시간 확인",
    "비동기 스크립트 요청 방식 변경",
    "브라우저 호환 이슈 (IE, iOS 등)"
  ],
  "context": "[STEP 1-1] WC 2.0 운영 개요\n[STEP 1-2] 시스템 구성 요소 및 연동 흐름\n[STEP 1-3] install.js와 ntm.js 차이 및 요청 프로세스\n[STEP 1-4] 스크립트 반영 주기 및 캐시\n[STEP 1-5] 스크립트 배포 방식 및 복사 기능\n[STEP 1-6] 스크립트 중복 삽입 방지 및 배포 시간 확인\n[STEP 1-7] 비동기 스크립트 요청 방식 변경\n[STEP 1-8] 브라우저 호환 이슈 (IE, iOS 등)\n[STEP 1-1] WC 2.0 운영 개요\n✅ 개념 요약\nWiseCollector 2.0은 웹 페이지 내 사용자 행태를 수집하기 위한\n스크립트 기반 수집 솔루션\n입니다.\n웹 페이지에 설치된\ninstall.js\n와\nntm.js\n가 브라우저 동작을 감지하고, 수집 서버(Nlogger)로 이벤트 로그를 전송합니다.\n이 수집된 로그는 통계 분석, 사용자 행동 추적, 마케팅 퍼널 분석 등에 활용됩니다.\nWiseCollector는\n데이터 수집의 유연성과 실시간성\n을 강화하며, 다양한 웹 환경(SPA, 웹뷰, 모바일 브라우저 등)에서의 대응을 고려한 구조로 설계되어 있습니다.\n✅ 주요 구성 요소\n구성 요소\n설명\ninstall.js\n웹 페이지에 삽입되는 최초 스크립트. ntm.js를 호출하고 초기 설정을 담당\nntm.js\n태그 실행, 변수 처리, 트리거 감지 등을 수행하는 핵심 실행 스크립트\nNlogger\n수집 서버. 브라우저에서 전송된 이벤트 로그를 수신하고 저장\nManager\nUI 기반 설정 서버. 태그, 트리거, 변수 설정 및 배포 관리\nAgent\n백엔드 연동 설정, 인증키 관리, 프록시 연동 등 다양한 중계 기능 수행\n✅ 시스템 동작 흐름 요약\n클라이언트가 접속하는 웹 페이지에\ninstall.js 삽입\ninstall.js →\nntm.js 로드\n→ 설정된\n태그 실행\n사용자 이벤트 발생 시\n트리거 감지\n→ 수집 조건에 맞는\n로그 전송\n로그는\nNlogger →\nCollector\n→ DB 저장\n추후 DataStory, UserFlow 등의 도구를 통해 시각화 및 리포트 생성\n📌 실무에서의 팁\nWiseCollector는\n브라우저 내부 동작을 해석하고 수집하는\n비동기\n구조\n를 갖습니다.\n운영 환경에 따라 다양한 스크립트 배포 전략과 프록시 설정을 적용할 수 있으며,\nSPA 대응\n과\n브라우저 호환성\n이 실전 운영에서 매우 중요합니다.\n태깅 구조는\nManager UI\n를 통해 설정되며, 설정된 결과는\nntm.js\n에 반영됩니다.\n📌 학습 체크포인트\ninstall.js\n와\nntm.js\n의 역할을 구분할 수 있나요?\n로그가 수집되는 전체 흐름을 말로 설명해볼 수 있나요?\nWiseCollector의 주요 구성 요소(install.js, ntm.js, Nlogger, Manager, Agent)의 기능을 1문장으로 요약할 수 있나요?\n[STEP 1-2] 시스템 구성 요소 및 연동 흐름\n✅ 개념 요약\nWiseCollector 2.0은 다양한 구성 요소가 함께 작동하여 브라우저 사용자 행동을 수집하고, 이를 로그로 저장한 뒤 분석 시스템과 연계합니다.\n이 구성은\n스크립트 → 수집 → 처리 → 저장/분석\n이라는 단계를 따르며, 각 단계별 구성 요소가 분리되어 있어 모듈화된 확장성이 뛰어납니다.\n✅ 구성 요소 및 역할\n구성 요소\n설명\ninstall.js\n웹 페이지에 직접 삽입되어 초기 실행되는 경량 스크립트. ntm.js를 호출\nntm.js\n이벤트 감지, 태그 실행, 변수 수집 등 핵심 로직이 담긴 스크립트\nNlogger (수집서버)\nntm.js로부터 전송된 데이터를 수신하고, 필터링 및 저장 전처리\nCollector / Kafka\n수집된 이벤트를 큐잉하여 분석 시스템이나 저장소로 전달\nManager (설정 서버)\nUI를 통해 태그·변수·트리거 설정. 결과를 ntm.js로 반영\nAgent\n시스템 운영/인증/프록시 처리 담당. 구성 요소 간 브리지 역할 수행\n통합로그인 시스템\n사용자 인증을 통해 Manager에 접근하는 SSO 기반 보안 구조\n✅ 연동 흐름 요약\n클라이언트 페이지에 설치된\ninstall.js\n가 로드됨\ninstall.js\n는 설정된 경로의\nntm.js\n를 동적으로 로드\nntm.js\n는 설정된 조건에 따라\n태그를 실행\n하고 이벤트를 감지\n감지된 이벤트는\nNlogger로 전송\nNlogger는 Collector와 Kafka를 통해 로그를 저장하거나 분석 시스템에 연계\n설정 변경은 Manager에서 수행되며, ntm.js에 자동 반영됨\n💡 SPA, 웹뷰 환경 등에서도 비동기 처리, 커스텀 트리거(fireUserDefined 등)로 유연하게 적용됨\n✅\n시스템 구성도\n예시(설치 환경 기준)\ninstall.js → ntm.js → Nlogger → Kafka → ClickHouse / DataStory\nManager & Agent는 설정·인증 및 배포 관리 전담\n통합로그인은 인증 시 Manager 접근을 보호함\n📌 학습 체크포인트\nWiseCollector의 주요 구성 요소를 나열하고 역할을 설명할 수 있나요?\n스크립트가 사용자 이벤트를 수집하여 로그로 저장되기까지의 흐름을 그려볼 수 있나요?\ninstall.js → ntm.js → Nlogger\n흐름에서 각 역할이 분리된 이유는 무엇인가요?\n[STEP 1-3] install.js와 ntm.js의 차이 및 요청 프로세스\n✅ 개념 요약\nWiseCollector는 브라우저에 삽입된 두 개의 핵심 스크립트인\ninstall.js\n와\nntm.js\n를 통해 웹 이벤트를 감지하고 로그를 수집합니다.\n이 두 파일은 명확한 역할 분담을 갖고 있으며, 요청 프로세스 또한 비동기적 흐름으로 최적화되어 있습니다.\n스크립트 서버의 상태를 사전 확인하고, 비정상 시 서비스 영향 없이 무시하는 설계를 통해\n웹페이지의 안정성\n을 높입니다.\n✅ 스크립트 역할 비교\n항목\ninstall.js\nntm.js\n실행 위치\n웹 페이지에 직접 삽입됨\ninstall.js에 의해 로드됨\n역할\nntm.js 호출 및 설정 초기화\n태그 실행, 트리거 감지, 로그 전송\n크기\n경량 (로드용)\n상대적으로 크며 로직 포함\n구성\n버전 및 환경설정 포함\n설정된 태그, 변수, 트리거 포함\n업데이트 주기\n공통 스크립트 기준\ninstall.js에 의해 반영됨\n✅ 요청 흐름 요약\n사용자가 웹 페이지에 접근하면\ninstall.js가 먼저 호출\n호출 전, install.js를 서비스하는 서버가 정상 동작 중인지\nxhr 방식으로 체크\n문제가 없을 경우 install.js 호출 → 이어서\nntm.js 자동 호출\nntm.js는 설정된 트리거에 따라 클릭, 페이지 이동 등 이벤트 감지\n이벤트가 감지되면\nNlogger로 로그 전송\n💡\n비정상 시 보호 로직\n서버 체크 실패 시 install.js 호출을 생략함 →\n서비스 영향 없음\n✅ 비동기 요청 처리 방식\ninstall.js 및 ntm.js는 HTML에서\n<script async>\n속성으로 삽입되어\n브라우저 렌더링과 병렬로 동작\n합니다.\n이는 HTML 파싱 지연을 막고, 페이지 로딩 속도를 최적화합니다.\nxhr 요청의 타임아웃은\n기본적으로 1초\n로 설정되어 있으며, 필요 시 변경 가능\n💡 “install.js 요청 전에 먼저 서버 상태를 확인하고, 문제 없을 경우에만 비동기 로딩”\n→ 서버가 죽어 있어도 페이지는 문제없이 로드됨\n📌 학습 체크포인트\n왜 install.js 호출 전에 서버 상태를 체크하는지 이해하고 있나요?\n<script async>\n속성을 사용하는 이유와 효과를 설명할 수 있나요?\n요청 실패 시 웹페이지에 어떤 영향을 주지 않는 구조인지 이해하고 있나요?\n[STEP 1-4] 스크립트 반영 주기 및 캐시\n✅ 개념 요약\n웹페이지에 삽입된\ninstall.js\n와\nntm.js\n는 일정한\n업데이트 주기\n에 따라 변경되며,\n브라우저와 프록시 서버의 캐시 정책\n에 의해 재사용됩니다.\n이는 네트워크 리소스를 절약하고 성능을 높이기 위한 구조이며, 설정된 주기에 따라 브라우저는 최신 스크립트를 다시 요청하거나 기존 캐시를 사용하게 됩니다.\n✅ 캐시 구조 이해\n구분\n설명\n브라우저 캐시\n클라이언트 디스크 또는 메모리에 저장되어 동일한 리소스를 재요청하지 않도록 함\n프록시 서버 캐시\n사용자 요청이 많은 객체를 중간 서버에 저장하여 빠르게 응답 가능\nWC 동작 방식\ninstall.js와 ntm.js는 브라우저와 프록시 정책 모두에 따라 캐시될 수 있음\n💡 실제로는 요청 전\nver 값\n을 확인하고, 동일하면 캐시 사용, 다르면 서버 재요청이 발생합니다.\n✅ 스크립트 업데이트 주기 설정\ninstall.js\n: UI에서 직접 업데이트 주기를 설정 가능\nntm.js\n: install.js에 포함된 설정 값에 따라 자동 적용됨\n💡 설정 예시 (ver 값 적용 기준)\n주기\n갱신 시간 (GMT 기준)\n하루 1회\n00시, 09시\n12시간\n00시, 12시, 09시, 21시\n6시간\n00, 06, 12, 18시 등\n1시간\n매시 정각\n매 요청마다\n요청된 시각마다 실시간 반영\n💡 업데이트 주기를 짧게 설정할수록 배포 즉시 적용되지만, 캐시 효율이 떨어질 수 있습니다.\n✅ 동작 방식 요약\ninstall.js → ntm.js 요청 시\n, 설정된 주기에 따라\nver\n쿼리스트링이 붙음\n동일한 ver이면\n캐시 파일 사용\n, 다르면\n새로 로딩\n캐시된 상태에서는\n서버로 요청하지 않음\n캐시가 없거나 주기가 만료된 경우, 서버에서 최신 파일 다운로드\n📌 학습 체크포인트\n브라우저 캐시와 프록시 캐시의 차이를 설명할 수 있나요?\ninstall.js와 ntm.js의 업데이트 주기 설정이 어떻게 연결되는지 이해하고 있나요?\n업데이트 주기를 짧게 설정했을 때의 장단점을 설명할 수 있나요?\nver 값이 같을 때와 다를 때, 브라우저가 어떻게 동작하는지 알고 있나요?\n[STEP 1-5] 스크립트 배포 방식 및 복사 기능\n✅ 개념 요약\nWiseCollector의 스크립트(\ninstall.js\n,\nntm.js\n)는 다양한 방식으로 웹사이트에 배포될 수 있으며,\n특정 설정이나 테스트를 위한\n스크립트 복사 기능\n도 제공됩니다.\n배포 방식은 주로\nAgent 기반, Script 실행 기반, 다운로드 기반\n으로 나뉘며,\n복사 기능은 미리보기 상태에서 스크립트를 추출해 개발자 도구에서 직접 실행해볼 수 있도록 지원합니다.\n✅ 스크립트 배포 방식 요약\n배포 방식\n설명\n적용 대상\nAgent 기반\n설치된 Agent와 통신해 스크립트를 원격 배포\n복수 서버에 동시 전송 필요할 때 적합\nScript 실행 기반\npost-update.sh 등의 스크립트를 수동 실행\n커스터마이징 높은 환경\n다운로드 기반\n파일을 직접 다운로드하여 서버에 수동 적용\n테스트 환경 또는 외부망 서비스\n💡 설정 경로:\nmanager/bin/process.properties\n,\nagent/bin/application.properties\n,\npost-update.sh\n서버 재시작이 필요한 경우도 있음\n✅ 배포 방식 비교 정리\n항목\nAgent 방식\nScript 방식\nDownload 방식\n배포 주체\nManager → Agent\nShell Script 실행\n사용자가 직접 적용\n자동화 수준\n높음\n중간\n낮음\n서버 재시작 여부\n필요\n없음 또는 수동 설정\n없음\n사용 예\n운영환경 배포\n개발/스테이징\n테스트 또는 예외 환경\n✅ 스크립트 복사 기능 (미리보기 활용)\n테스트 시 ntm.js의 로직을 직접 복사하여\n브라우저 콘솔에서 실행\n할 수 있는 기능입니다.\n단, 페이지 이동 시 적용이 해제되므로 재삽입이 필요합니다.\n💡 사용 절차\n컨테이너 생성\n후 트리거/태그 설정\n미리보기 모드 실행\nAlt 키를 누른 상태에서\n‘적용’ 버튼 클릭\n→ “스크립트 코드가 클립보드에 복사되었습니다” 메시지 확인\n브라우저 Console 탭\n에서 붙여넣기 후 Enter\n실행 확인 및 태그 정상작동 테스트\n⚠️\n주의사항\n: 페이지 전환 시 복사된 스크립트는 초기화됨\n📌 학습 체크포인트\nAgent / Script / Download 방식 각각의 특징을 설명할 수 있나요?\n미리보기 상태에서 복사된 스크립트는 어떤 환경에서 활용되나요?\n스크립트 배포 시 서버 재시작이 필요한 경우와 그렇지 않은 경우를 구분할 수 있나요?\n운영 중에 가장 안정적인 배포 방식은 어떤 상황에 적합할까요?\n[STEP 1-6] 스크립트 중복 삽입 방지 및 배포 시간 확인\n✅ 개념 요약\nWiseCollector의 스크립트는 페이지 내에 한 번만 삽입되어야 하며,\n중복 삽입 시 동일한 이벤트가 반복 실행되거나, 로직 충돌이 발생할 수 있습니다.\n또한 스크립트의 적용 시점과 반영 여부를 확인하려면\n배포 시간 확인 방법\n도 알아두어야 합니다.\n✅ 스크립트 중복 삽입 방지\n💡 중복 삽입 문제의 원인\n동일한 install.js 혹은 ntm.js가\n두 번 이상 삽입\nSPA 구조 또는 잘못된 빌드에서\n동일한 script 태그가 중복 생성\n결과적으로\n이중 로깅\n,\n트리거 반복 실행\n,\n오류 로그 발생\n등 문제가 유발됨\n💡 방지 방법\n스크립트 삽입 시 고유 ID 또는 전역 변수로 존재 여부 확인\n예:\nif (!window._ntmLoaded) { ... window._ntmLoaded = true; }\n빌드 시점(React, Vue 등)에서는 페이지 전환마다 삽입되지 않도록 모듈 로딩 위치 조정\nSPA 환경에서는 **fireUserDefined()**를 활용한 트리거 처리로 대체 권장\n💡\n관련 내용:\n중복 삽입 방지 가이드\n✅ 스크립트 배포 시간 확인\n스크립트 파일(\nntm.js\n)의 실제 배포 시간은 브라우저 개발자 도구에서 확인할 수 있습니다.\n💡 확인 방법 (Chrome 기준)\nF12 키 또는 우클릭 → “검사(Inspect)”로 개발자 도구 실행\n“Network” 탭 클릭\n필터에서\nntm.js\n검색 → 해당 파일 클릭\n“Headers” 탭에서\nLast-Modified\n항목 확인\n해당 값은 서버에서 마지막으로 수정된 시각 (즉, 배포된 시점)\n💡 이 시각이 너무 오래되었다면 캐시가 갱신되지 않았거나 배포가 누락된 것일 수 있음\n→ 브라우저 캐시 초기화 또는 서버 side 갱신 확인 필요\n📌 학습 체크포인트\n동일한 스크립트를 두 번 삽입했을 때 발생할 수 있는 문제는 무엇인가요?\n중복 삽입을 방지하기 위한 코드 또는 설계 방식에는 어떤 것이 있나요?\nntm.js\n의 배포 시간을 확인하는 구체적인 방법을 설명할 수 있나요?\n캐시가 갱신되지 않은 상태에서 발생할 수 있는 오해를 하나 들어볼 수 있나요?\n[STEP 1-7] 비동기 스크립트 요청 방식 변경\n✅ 개념 요약\nWiseCollector에서는 스크립트 요청을\n동기식(Sync)\n방식에서\n비동기식(Async, xhr)\n방식으로 전환하여\n서비스 안정성과 성능을 동시에 확보하고자 합니다.\n비동기식 요청은 서버 응답을 기다리지 않고 병렬 처리되며\n, 요청 실패 시에도 브라우저 렌더링이나 사용자 경험에 영향을 주지 않는다는 장점이 있습니다.\n다만, 이를 위해선 서버에\nCORS 설정이 필수\n이며, 이를 만족하지 못할 경우 요청이 실패할 수 있습니다.\n✅ 요청 방식 비교\n항목\n동기식 요청\n비동기식 요청 (xhr)\n실행 방식\n순차 실행 (브라우저가 대기함)\n병렬 처리 (비대기)\n실패 시 영향\n페이지 렌더링 차단 가능성 있음\n렌더링 영향 없음\n속도\n상대적으로 느릴 수 있음\n빠름\n설정 필요\n별도 설정 없음\nCORS 설정 필요\n타임아웃 설정\n없음\n가능 (기본 1초)\n✅ 변경 적용 방법\n스크립트를 비동기 요청으로 전환하기 위해서는 다음과 같은 절차가 필요합니다:\ninstall.min.html\n백업\ninstall.ajax.min.html\n→\ninstall.min.html\n로 리네이밍\nManager →\n스크립트 설치 메뉴 이동\n소스코드 복사 후 고객사 웹페이지에 적용\n💡 비동기 요청 타임아웃은 기본\n1초\n로 설정되어 있으며, 변경 필요 시 1000ms → 원하는 값으로 수정 가능\n✅ async 속성 설명 (HTML 태그 기준)\n<script async src=\"...\"></script>\n스크립트가 다운로드와 병행하여 실행되며,\nHTML 파싱과 병렬로 실행됨\nHTML 파서가 기다리지 않기 때문에 페이지 로딩 속도 향상에 도움\ninstall.js 및 ntm.js 모두 async로 요청되는 구조로 설정됨\n✅ 모바일 웹뷰 유의사항\niOS 등의 앱 웹뷰 환경에서는 로딩 인디케이터(UIActivityIndicatorView)가\n비동기 요청을 완료하지 못한 상태\n에서 동작 종료될 수 있음\n→ 이 경우\n화면상 \"로딩중\"이 계속 유지\n될 수 있음\n📌 학습 체크포인트\n비동기 요청 방식(xhr)을 사용하는 이유는 무엇인가요?\n요청 방식 변경 시 필요한 서버 측 설정은 어떤 것인가요?\nasync 속성이 HTML 태그에서 어떤 역할을 하나요?\n웹뷰 환경에서 비동기 요청이 문제를 일으킬 수 있는 상황을 설명할 수 있나요?\n[STEP 1-8] 브라우저 호환 이슈 (IE, iOS 등)\n✅ 개념 요약\nWiseCollector 스크립트는 다양한 브라우저에서 동작하지만, 일부 환경에서는\n스크립트 기능 제한\n이나\n정규표현식, ES6 문법 등 JS 지원 미흡\n으로 인해 오류가 발생할 수 있습니다.\n특히 iOS Safari의 버전별 기능 제한과 Internet Explorer(IE)는 설치·로딩·로그 수집 방식에서 제약이 있습니다.\n✅ iOS 브라우저별 이슈\n💡 주요 제한 기능 및 버전별 지원 현황\n기능\n지원 시작 버전\nMutationObserver (DOM 감지)\niOS Safari 6 이상\ncrypto.getRandomValues()\niOS Safari 7 이상\nhistory.pushState / replaceState\niOS Safari 5 이상\nTextEncoder (UTF-8 인코딩)\niOS Safari 10.3 이상\n대부분의 ES6 기능 (let, const, Promise 등)\niOS Safari 10 이상 완전 지원\n복잡한 RegExp,\n.split()\n,\n.match()\n일부 버전에서 비정상 동작 가능\n💡 결론:\nntm.js는 iOS Safari 10.3 이상부터 정상 동작\n그 이하 버전에서는 스크립트 오류, 정규표현식 실패, 트리거 오작동 등 발생 가능\n✅ Internet Explorer(IE) 이슈\n💡 IE9 이상\n정상적으로 install.js → ntm.js → 태깅 실행 흐름 작동\n기본 이벤트 수집 및 클릭 수집 동작 정상\n💡 IE8 이하\ninstall.js 내부에서 사용자 에이전트를 확인하여\n별도 분기 처리\ncustomFunc() 내부에 기능을 삽입해야만 동작 가능\n새로운 함수, 이벤트는 정상적으로 동작하지 않음\nURL 요청 길이 2,083자 제한\n존재\n💡 결론:\nIE는 공식 지원 대상 아님\n. 최신 기능은 정상 작동 보장 불가\n📌 실무에서의 팁\n모바일 iOS Safari 사용자가 많은 사이트에서는\n브라우저 버전별 분기 처리\n를 고려해야 합니다.\n브라우저 기능 테스트 시\nwindow.navigator.userAgent\n를 이용해 환경을 감지합니다.\nntm.js 내부에서 사용하는 고급 스크립트 기능(ES6, MutationObserver 등)의\n폴리필 또는 대체 로직 고려\n가 필요합다.\n📌 학습 체크포인트\niOS에서\nntm.js\n가 안정적으로 동작하려면 최소 몇 버전 이상이 필요할까요?\nSafari 9에서 let/const 문법을 사용한 스크립트는 정상 실행될까요?\nIE8 이하 브라우저에서 WC 스크립트를 사용할 경우 어떤 대체 방식이 적용되어야 하나요?\n브라우저 기능 제약을 고려해 어떤 테스트 항목을 사전 확인해야 할까요?"
}